import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url'; // Import fileURLToPath
// Get the directory name of the current module in ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const typesFilePath = path.join(__dirname, '../src/types.ts');
const projectRoot = path.join(__dirname, '..'); // This should correctly go up one level from 'scripts'
const outputFilePath = path.join(projectRoot, 'src/generated/knownTrackables.ts');
const outputDir = path.dirname(outputFilePath);

console.log('Generating trackables from types.ts...');

try {
    const typesContent = fs.readFileSync(typesFilePath, 'utf-8');

    const extractUnionLiterals = (content: string, interfaceName: string, propertyName: string): string[] => {
        // Regex to find the property and its union type string literals
        // This is a simplified regex and might need adjustment based on exact formatting
        // It looks for: propertyName: "Literal1" | "Literal2" | ... ; or ,
        const regexPattern = new RegExp(
            `${propertyName}\\s*:\\s*([\\s\\S]*?)(?:;|,)`,
            'gm'
        );

        let match;
        let literalsRaw = '';
        // Find the interface block first to narrow down search for the property
        const interfaceRegex = new RegExp(`interface\\s+${interfaceName}\\s*\\{[\\s\\S]*?\\}`, 'gm');
        const interfaceMatch = interfaceRegex.exec(content);

        if (interfaceMatch) {
            const interfaceContent = interfaceMatch[0];
            // Now search for the property within this interface content
            while ((match = regexPattern.exec(interfaceContent)) !== null) {
                // Check if this match is indeed the one we want (could be other properties with same name in comments/other contexts)
                // A more robust check would be needed here if the structure is complex.
                // For now, assume first good match inside interface is it.
                literalsRaw = match[1];
                break;
            }
        }

        if (!literalsRaw) {
            console.warn(`Could not find property '${propertyName}' in interface '${interfaceName}' or its union literals.`);
            return [];
        }

        // Extract quoted strings from the matched union type part
        const stringLiteralRegex = /"([^"]+)"/g;
        const literals: string[] = [];
        let literalMatch;
        while ((literalMatch = stringLiteralRegex.exec(literalsRaw)) !== null) {
            if (literalMatch[1] !== 'string') { // Exclude the generic 'string' type
                literals.push(literalMatch[1]);
            }
        }
        return [...new Set(literals)].sort(); // Unique and sorted
    };

    const resourceNames = extractUnionLiterals(typesContent, 'TrackedResource', 'name');
    const flagNames = extractUnionLiterals(typesContent, 'AcquiredItemFlag', 'itemName');

    if (resourceNames.length === 0) {
        console.warn("Warning: No resource names extracted. Check regex or types.ts structure for TrackedResource['name'].");
    }
    if (flagNames.length === 0) {
        console.warn("Warning: No flag names extracted. Check regex or types.ts structure for AcquiredItemFlag['itemName'].");
    }

    const outputContent = `// THIS FILE IS AUTO-GENERATED BY scripts/generate-trackables.ts. DO NOT EDIT MANUALLY.
// Timestamp: ${new Date().toISOString()}

export const KNOWN_TRACKED_RESOURCE_NAMES: string[] = ${JSON.stringify(resourceNames, null, 2)};

export const KNOWN_ACQUIRED_ITEM_FLAG_NAMES: string[] = ${JSON.stringify(flagNames, null, 2)};
`;

    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    fs.writeFileSync(outputFilePath, outputContent, 'utf-8');
    console.log(`Successfully generated ${outputFilePath}`);

} catch (error) {
    console.error('Error generating trackables:', error);
    process.exit(1); // Exit with error code if script fails
}